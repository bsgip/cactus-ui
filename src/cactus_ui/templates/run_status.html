{% extends "base.html" %}

{% block title %}Run Status {{ run_id }} - CACTUS{% endblock %}

{% block content %}


{% if error %}
<div class="alert alert-danger">{{ error }}</div>
{% endif %}


{% if run_is_live %}
<div id="error-div"></div>

<div class="row justify-content-center">
    <div class="card status-container">
        <div class="card-body">
            <h5 class="card-title">Run {{ run_id }} ({{ run_status }})</h5>

            <p class="card-text">
                <code style="user-select: all;">{{ run_test_uri }}</code>
            </p>

            {% if run_status == 'initialised' %}
            <div id="update-initialised-card"></div>
            {% elif run_status == 'started' %}
            <p class="card-text">The test is now underway - the server will have loaded any initial preconditions
                (eg: DERControls) and its now time for your client to respond appropriately.</p>
                <p>When you're ready to end the test, press the Finalise button. An artefact will be downloaded including
                    a PDF report, request logs, and server logs to help with debugging.
                </p>
            <form id='finalise-form' method="POST">
                <input type="hidden" name="action" value="finalise">
                <button {{user_buttons_state}} type="submit" class="btn btn-warning" onclick="handleButtonClick(event)">Finalise</button>
            </form>
            {% endif %}

        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container">
        <div class="card-body">
            <h5 class="card-title"><a href="{{ url_for('procedure_yaml_page', test_procedure_id=run_procedure_id) }}">
                    {{ run_procedure_id }}
                </a></h5>
            <table class="table">
                <tbody id="update-general-table"></tbody>
            </table>
        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container" id="precondition-checks-card">
        <div class="card-body">
            <h5 class="card-title">Precondition Checks</h5>
            <table class="table">
                <tbody id="update-precondition-checks-table"></tbody>
            </table>
        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container ">
        <div class="card-body">
            <h5 class="card-title">Current Criteria</h5>
            <table class="table">
                <tbody id="update-criteria-table"></tbody>
            </table>
        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container ">
        <div class="card-body">
            <h5 class="card-title">Steps</h5>
            <div id="step-instructions"></div>
            <table class="table">
                <tbody id="update-steps-table"></tbody>
            </table>
        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container timeline-container">
        <div class="card-body">
            <h5 class="card-title">Timeline</h5>
            <div id="timelineInfo" class="alert alert-info" style="display: none;"></div>
            <canvas id="timelineChart"></canvas>
            <canvas id="timelineActivityChart" style="margin-top: 10px; height: 80px;"></canvas>
        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container">
        <div class="card-body">
            <h5 class="card-title">Active Device Metadata</h5>
            <table class="table">
                <tbody id="update-metadata-table"></tbody>
            </table>
        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container ">
        <div class="card-body">
            <h5 class="card-title">CSIP-Aus Requests</h5>
            <table class="table">
                <tbody id="update-requests-table"></tbody>
            </table>
        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container ">
        <div class="card-body">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h5 class="card-title mb-0" id="xsd-section-title">Latest XSD Validation Error</h5>
                <div class="btn-group" role="group" id="xsd-navigation">
                </div>
            </div>
            <table class="table">
                <tbody id="update-xsd-table"></tbody>
            </table>
        </div>
    </div>
</div>
<br>
<div class="row justify-content-center">
    <div class="card status-container ">
        <div class="card-body">
            <h5 class="card-title">Envoy Logs</h5>
            <pre id="update-log-envoy">Loading...</pre>
        </div>
    </div>
</div>

{% else %}

<div class="row">
    <h2>Run {{ run_id }} [Finalised]</h2>
    <div class="alert alert-primary" role="alert">
        <p>This run has been finalised and is no longer active.</p>
        <p>Click the button below to download the run's artifacts.</p>
        <form id='download-form' method="POST" action="{{ url_for('run_status_page', run_id=run_id) }}">
            <input type="hidden" name="action" value="artifact">
            <button type="submit" class="btn btn-primary">Download Artifacts</button>
        </form>
    </div>


</div>



{% endif %}


<style>
    .status-container {
        max-width: 1000px;
        max-height: 600px;
        overflow-y: auto;
    }
    #update-xsd-table th {
        width: 120px;
        white-space: nowrap;
    }
    #requestModal .modal-backdrop {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); z-index: 9999;
        display: flex; align-items: center; justify-content: center;
        overflow: hidden;
    }
    #requestModal .modal-content {
        background: white; width: 90%; max-width: 1200px; max-height: 90vh;
        padding: 20px; overflow-y: auto; overflow-x: hidden;
    }
    #requestModal .modal-header {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 15px;
    }
    #requestModal .modal-header button {
        border: none; background: none; font-size: 24px; cursor: pointer;
    }
    #requestModal pre {
        background: #f8f9fa; padding: 10px; overflow-x: auto;
    }
    body.modal-open {
        overflow: hidden;
    }
    .timeline-container {
        max-height: 900px;
    }
</style>

<script>
    var timelineChart = null;
    var timelineActivityChart = null;
    var cachedXsdRequests = null;
    const runId = parseInt("{{ run_id }}");
    const isAdminView = "{{ is_admin_view }}" === 'True';
    const userButtonsState = "{{ user_buttons_state }}";
    const runIsLive = "{{ run_is_live }}" === 'True';
    const userRunStatusUri = "{{ url_for('run_status_page', run_id=run_id) }}";
    const adminRunStatusUri = "{{ url_for('admin_run_status_page', run_id=run_id) }}";
    const runStatusUri = isAdminView ? adminRunStatusUri : userRunStatusUri;
    const formAction = runStatusUri 
    

    if (isAdminView) {
        // Update actions for forms defined in template
        const downloadForm = document.getElementById('download-form');
        if (downloadForm) {
            downloadForm.action = formAction;
        }

        const finaliseForm = document.getElementById('finalise-form');
        if (finaliseForm) {
            finaliseForm.action = formAction;
        }
    }

    function handleButtonClick(e) {
        e.target.innerHTML = `<div class="spinner-border spinner-border-sm" role="status"></div>`;
        e.target.disabled = true;
        e.target.closest('form').submit();
    }

    function getStepColor(stepName, index) {
        const defaultColors = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
            '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
            '#393b79', '#637939', '#8c6d31', '#843c39', '#7b4173',
            '#5254a3', '#8ca252', '#bd9e39', '#ad494a', '#a55194'
        ];
        return defaultColors[index % defaultColors.length];
    }

    function parseOffsetSeconds(offsetStr) {
        const match = offsetStr.match(/(\d+)m(\d+)s|(\d+)s/);
        if (!match) return 0;
        
        if (match[1] && match[2]) {
            return parseInt(match[1]) * 60 + parseInt(match[2]);
        }
        return parseInt(match[3]) || 0;
    }

    function formatTimeLabel(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return mins > 0 ? `${mins}m${secs}s` : `${secs}s`;
    }

    function showCommsError(message) {
        const errorEl = document.getElementById('error-div');
        if (!errorEl) return;
        
        errorEl.innerHTML = message 
            ? `<div class="alert alert-danger" role="alert">${message}</div>`
            : '';
    }

    // TABLES   

    function generalTableBody(status) {
        fragments = [];

        if (status.timestamp_start) {
            startTime = new Date(Date.parse(status.timestamp_start))
            fragments.push(`
                <tr>
                    <th scope="row">Started</th>
                    <td>${formatDate(startTime)} (${formatRelativeDate(startTime)})</td>
                </tr>`
            );
        }

        if (status.timestamp_initialise) {
            init_time = new Date(Date.parse(status.timestamp_initialise))
            fragments.push(`
                <tr>
                    <th scope="row">Created</th>
                    <td>${formatDate(init_time)} (${formatRelativeDate(init_time)})</td>
                </tr>`
            );
        }

        const timestamp = status.last_client_interaction?.timestamp ?? null;
        if (timestamp) {
            interaction_time = new Date(Date.parse(timestamp));
            fragments.push(`
                <tr>
                    <th scope="row">Last Interaction</th>
                    <td>${formatDate(interaction_time)} (${formatRelativeDate(interaction_time)})</td>
                </tr>`
            );
        }

        fragments.push(`
            <tr>
                <th scope="row">Summary</th>
                <td>${status.status_summary}</td>
            </tr>`
        );

        return fragments;
    }

    function metadataTableBody(endDeviceMetadata) {
        fragments = [];
        
        // Helper function to display value or "Not set"
        const displayValue = (value) => value !== null && value !== undefined ? value : "Not set";
        
        // Always display all rows
        fragments.push(`
            <tr>
                <th scope="row">End Device href</th>
                <td>${displayValue(endDeviceMetadata?.edevid)}</td>
            </tr>
            <tr>
                <th scope="row">LFDI</th>
                <td>${displayValue(endDeviceMetadata?.lfdi)}</td>
            </tr>
            <tr>
                <th scope="row">NMI</th>
                <td>${displayValue(endDeviceMetadata?.nmi)}</td>
            </tr>
            <tr>
                <th scope="row">Set Max W (W)</th>
                <td>${displayValue(endDeviceMetadata?.set_max_w)}</td>
            </tr>`
        );
        
        return fragments;
    }

    function preconditionChecksTableBody(preconditionChecks) {
        fragments = []
        for (const c of preconditionChecks) {
            color = c.success ? "success" : "danger";
            icon = c.success ? "check" : "x";
            fragments.push(`
                <tr>
                    <th scope="row">${c.type}</th>
                    <td><span class="text-${color}"><i class="fas fa-${icon}"></i></span></td>
                    <td>${c.details}</td>
                </tr>
            `)
        }
        return fragments.join('');
    }

    function criteriaTableBody(criteria) {
        const fragments = []
        for (const c of criteria) {
            color = c.success ? "success" : "danger";
            icon = c.success ? "check" : "x";
            fragments.push(`
                <tr>
                    <th scope="row">${c.type}</th>
                    <td><span class="text-${color}"><i class="fas fa-${icon}"></i></span></td>
                    <td>${c.details}</td>
                </tr>
            `)
        }
        return fragments
    }

    function stepStatusTableBody(stepStatus) {
        fragments = []
        for (const [step, stepInfo] of Object.entries(stepStatus)) {
            // Handle both old format (number) and new format (object)
            let status;
            if (typeof stepInfo == 'number') {
                // Legacy format
                status = stepInfo;
            } else {
                // New format - derive status from StepInfo
                if (stepInfo.completed_at) {
                    status = 2; // RESOLVED
                } else if (stepInfo.started_at) {
                    status = 1; // ACTIVE
                } else {
                    status = 0; // PENDING
                }
            }
            
            let color = ""
            let icon = ""
            switch (status) {
                case 0:
                    //PENDING
                    color = "secondary"
                    icon = "minus"
                    break;
                case 1:
                    //ACTIVE
                    color = "primary"
                    icon = "play"
                    break;
                case 2:
                    //RESOLVED
                    color = "success"
                    icon = "check"
                    break;
                    
            }
            fragments.push(`
                <tr>
                    <th scope="row">${step}</th>
                    <td><span class="text-${color}"><i class="fas fa-${icon}"></i></span></td>
                </tr>`);
        }

        return fragments
    }

    function requestsTableBody(requests) {
        if (requests.length == 0) {
            return [`
            <tr>
                <th scope="row">No requests received</th>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>`];
        }

        fragments = []
        for (const r of requests) {
            d = new Date(Date.parse(r.timestamp))
            statusColor = r.status < 200 || r.status > 299 ? "danger" : "success"
            schemaColor = r.body_xml_errors.length ? "danger" : "success"
            schemaText = r.body_xml_errors.length ? "XSD Errors" : "XSD Valid"
            stepName = r.step_name === "Unmatched" ? "" : r.step_name

            fragments.push(`
            <tr>
                <th scope="row">${formatDate(d)}</th>
                <td>${r.method} ${r.path} <span class="badge text-bg-${statusColor}">${r.status}</span></td>
                <td>${stepName}</td>
                <td><span class="badge text-bg-${schemaColor}">${schemaText}</span></td>
                <td>
                    <button class="btn btn-sm btn-outline-primary" onclick="showRequestDetails(${r.request_id})">
                        Details
                    </button>
                </td>
            </tr>`);
        }

        return fragments
    }
    function xsdTableBody(requests) {
        // Only filter and sort once, or when requests change
        if (!cachedXsdRequests || cachedXsdRequests.sourceLength !== requests.length) {
            cachedXsdRequests = {
                list: requests
                    .filter(r => r.body_xml_errors && r.body_xml_errors.length > 0)
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                    .slice(0, 10),
                sourceLength: requests.length
            };
        }
        
        const requestsWithErrors = cachedXsdRequests.list;
        
        // Update the title based on count
        const titleElement = document.querySelector('#xsd-section-title');
        if (titleElement) {
            // Count total errors before slicing
            const totalErrorCount = requests
                .filter(r => r.body_xml_errors && r.body_xml_errors.length > 0)
                .length;
            
            if (requestsWithErrors.length === 0 || requestsWithErrors.length === 1) {
                titleElement.textContent = 'Latest XSD Validation Error';
            } else if (totalErrorCount > 10) {
                titleElement.textContent = `Latest XSD Validation Errors: Showing 10/${totalErrorCount}`;
            } else {
                titleElement.textContent = 'Latest XSD Validation Errors';
            }
        }
        
        if (requestsWithErrors.length === 0) {
            // Rmeove navigation
            document.getElementById('xsd-navigation').innerHTML = '';
            
            return [`
                <tr>
                    <td colspan="2" class="text-center text-muted">No XSD validation errors detected</td>
                </tr>`
            ];
        }
        
        const currentIndex = parseInt(document.getElementById('xsdErrorIndex')?.value || '0', 10);
        const currentRequest = requestsWithErrors[currentIndex];
        const errorTimestamp = new Date(Date.parse(currentRequest.timestamp));
        
        // Update navigation buttons
        const navContainer = document.getElementById('xsd-navigation');
        if (requestsWithErrors.length > 1) {
            navContainer.innerHTML = `
                <button type="button" class="btn btn-sm btn-outline-primary" 
                        onclick="cycleXsdError(-1)" 
                        ${currentIndex === 0 ? 'disabled' : ''}>
                    ← Previous
                </button>
                <button type="button" class="btn btn-sm btn-outline-secondary" disabled>
                    ${currentIndex + 1} of ${requestsWithErrors.length}
                </button>
                <button type="button" class="btn btn-sm btn-outline-primary" 
                        onclick="cycleXsdError(1)"
                        ${currentIndex === requestsWithErrors.length - 1 ? 'disabled' : ''}>
                    Next →
                </button>
                <input type="hidden" id="xsdErrorIndex" value="${currentIndex}">
                <input type="hidden" id="xsdErrorCount" value="${requestsWithErrors.length}">
            `;
        } else {
            navContainer.innerHTML = `
                <input type="hidden" id="xsdErrorIndex" value="0">
                <input type="hidden" id="xsdErrorCount" value="1">
            `;
        }
        
        const fragments = [];
        
        fragments.push(`
            <tr>
                <th scope="row">Timestamp</th>
                <td>${formatDate(errorTimestamp)} (${formatRelativeDate(errorTimestamp)})</td>
            </tr>
        `);
        
        fragments.push(`
            <tr>
                <th scope="row">Request</th>
                <td>${currentRequest.method} ${currentRequest.path}</td>
            </tr>
        `);
        
        fragments.push(`
            <tr>
                <th scope="row">URL</th>
                <td><code style="word-break: break-all;">${currentRequest.url}</code></td>
            </tr>
        `);
        
        fragments.push(`
            <tr>
                <th scope="row">Status Code</th>
                <td><span class="badge text-bg-${currentRequest.status < 200 || currentRequest.status > 299 ? 'danger' : 'success'}">${currentRequest.status}</span></td>
            </tr>
        `);
        
        fragments.push(`
            <tr>
                <th scope="row">Step</th>
                <td>${currentRequest.step_name === "Unmatched" ? "<em>Unmatched</em>" : currentRequest.step_name}</td>
            </tr>
        `);
        
        const MAX_ERROR_LENGTH = 500;
        const truncateError = (error) => {
            if (error.length <= MAX_ERROR_LENGTH) {
                return error;
            }
            return error.substring(0, MAX_ERROR_LENGTH) + '... <em>(truncated)</em>';
        };
        
        fragments.push(`
            <tr>
                <th scope="row">XSD Errors</th>
                <td>
                    <ul class="mb-0" style="max-height: 300px; overflow-y: auto;">
                        ${currentRequest.body_xml_errors.map(err => `<li><code style="white-space: pre-wrap; word-break: break-word;">${truncateError(err)}</code></li>`).join('')}
                    </ul>
                </td>
            </tr>
        `);

        fragments.push(`
            <tr>
                <th scope="row">Details</th>
                <td>
                    <button class="btn btn-sm btn-primary" onclick="showRequestDetails(${currentRequest.request_id})">
                        View Full Request Details
                    </button>
                </td>
            </tr>
        `);
        
        return fragments;
    }

    function cycleXsdError(direction) {
        const indexInput = document.getElementById('xsdErrorIndex');      // Current position
        const countInput = document.getElementById('xsdErrorCount');      // Total number of errors
        
        if (!indexInput || !countInput) return;  // Safety check
        
        // Get the current values
        const currentIndex = parseInt(indexInput.value, 10);  // e.g., error #2 (index 1)
        const maxCount = parseInt(countInput.value, 10);      // e.g., 5 total errors
        
        const newIndex = Math.max(0, Math.min(maxCount - 1, currentIndex + direction)); // Calculate the new index       
        indexInput.value = newIndex; // Update the stored index
        
        // Re-render the table
        const xsdTable = document.getElementById('update-xsd-table');
        xsdTable.innerHTML = xsdTableBody(window.currentStatus.request_history ?? []).join("");
    }

    function alertBanner(message) {
        return `
        <div class="alert alert-primary" role="alert">
            ${message}
        </div>`;
    }

    function getStepInstructions(instructions) {
        fragments = []
        fragments.push(`
        <p>
            <ul>
        `);
        for (const instruction of instructions) {
            fragments.push(`<li>${instruction}</li>`)
        }
        fragments.push(`
            </ul>
        </p>`);
        return fragments.join("");
    }

    function initialisedCardBody(instructions) {
        fragments = []

        const startButton = `
        <form method="POST" action="${formAction}">
            <input type="hidden" name="action" value="start">
            <button ${userButtonsState} type="submit" class="btn btn-primary" onclick="handleButtonClick(event)">Start</button>
        </form>`;

        if (instructions.length === 0) {
            fragments.push(`
            <p class="card-text">This run is currently in the pre-start phase. It can started at any time.</p>`);
            fragments.push(startButton);
        } else {
            fragments.push(`
            <div class="alert alert-primary" role="alert">
                <p>This run is currently in the pre-start phase.</p>
                <p>Please ensure the following <i>before</i> starting the test:</p>
                <ul>`);
            for (const instruction of instructions) {
                fragments.push(`<li>${instruction}</li>`)
            }
            fragments.push(`</ul>`);
            fragments.push(startButton);
            fragments.push(`</div>`);
        }
        return fragments.join("");
    }

    // CHARTS
    
    function calculateMaxTime(timeline, timelineStart) {
        let maxTime = 0;
        
        if (timelineStart) {
            maxTime = (new Date() - new Date(timelineStart)) / 1000;
        }

        timeline?.data_streams?.forEach(stream => {
            stream.data.forEach(point => {
                maxTime = Math.max(maxTime, parseOffsetSeconds(point.offset));
            });
        });

        return maxTime + Math.max(maxTime * 0.05, 15);
    }

    function convertDataStreamsToChartJs(dataStreams) {
        return dataStreams.map(ds => {
            // Sort data by offset time
            const sortedData = [...ds.data].sort((a, b) => 
                parseOffsetSeconds(a.offset) - parseOffsetSeconds(b.offset)
            );
            // Each point is stored as a 20s interval
            const expandedData = [];
            sortedData.forEach((point, index) => {
                const startX = parseOffsetSeconds(point.offset);
                const endX = startX + 20;
                
                // Add start point
                expandedData.push({ x: startX, y: point.watts });
                
                // If not at the end, check if there's a gap to the next segment
                if (index < sortedData.length - 1) {
                    const nextStartX = parseOffsetSeconds(sortedData[index + 1].offset);
                    
                    // Only add the end point if there's a gap, or if it's the last segment
                    if (nextStartX > endX) {
                        // There's a gap - add end point of current segment
                        expandedData.push({ x: endX, y: point.watts });
                    } else {
                        // No gap - the segments are contiguous, just continue
                        expandedData.push({ x: nextStartX, y: point.watts });
                    }
                } else {
                    // Last segment - add the end point
                    expandedData.push({ x: endX, y: point.watts });
                }
            });
            
            return {
                label: ds.label,
                data: expandedData,
                borderDash: ds.dashed ? [5, 5] : undefined,
                tension: 0,
                spanGaps: false
            };
        });
    }
    function createChartAnnotations(timeline, timelineStart) {
        const start = new Date(timelineStart);
        const nowSeconds = (new Date() - start) / 1000;
        
        const annotations = [{
            type: 'line',
            borderColor: 'black',
            borderWidth: 2,
            label: {
                display: true,
                content: 'Now',
                position: 'start',
                backgroundColor: 'rgba(0,0,0,0.8)',
                color: 'white'
            },
            scaleID: 'x',
            value: nowSeconds
        }];
        
        if (timeline?.set_max_w != null) {
            const maxW = timeline.set_max_w;
            [maxW, -maxW].forEach((value, idx) => {
                annotations.push({
                    type: 'line',
                    borderColor: 'black',
                    borderWidth: 3,
                    borderDash: [5, 5],
                    scaleID: 'y',
                    value: value,
                    label: {
                        display: true,
                        content: idx === 0 ? `Max: ${maxW}W` : `Min: -${maxW}W`,
                        position: 'end'
                    }
                });
            });
        }
        
        return annotations;
    }

    function extractActivityData(stepStatus, requestHistory, timelineStart) {
        if (!timelineStart) return { stepCompletions: [], allRequests: [] };
        
        const start = new Date(timelineStart);
        const stepCompletions = [];
        const allRequests = [];

        // Extract step completions
        Object.entries(stepStatus || {}).forEach(([stepName, stepInfo], idx) => {
            if (stepInfo.completed_at) {
                const timeOffset = (new Date(stepInfo.completed_at) - start) / 1000;
                if (timeOffset >= 0) {
                    stepCompletions.push({
                        stepName,
                        xPosition: timeOffset,
                        color: getStepColor(stepName, idx)
                    });
                }
            }
        });

        // Extract ALL request positions (treat all as "Requests")
        (requestHistory || []).forEach(request => {
            const timeOffset = (new Date(request.timestamp) - start) / 1000;
            if (timeOffset >= 0) {
                allRequests.push(timeOffset);
            }
        });

        return { stepCompletions, allRequests };
    }

    function createActivityDatasets(stepCompletions, allRequests) {
        const datasets = [];
        
        // Add step completions FIRST (for legend order, but will be drawn last)
        const stepLegendAdded = new Set();
        const completionLines = [];
        
        stepCompletions.forEach(completion => {
            const showInLegend = !stepLegendAdded.has(completion.stepName);
            
            if (showInLegend) {
                stepLegendAdded.add(completion.stepName);
                datasets.push({
                    label: `${completion.stepName} (completed)`,
                    data: [],
                    borderColor: completion.color,
                    borderWidth: 4,  // Increased from 3
                    pointRadius: 0
                });
            }

            // Store completion lines to add later (so they draw on top)
            completionLines.push({
                label: '',
                data: [
                    { x: completion.xPosition, y: 0.2 },
                    { x: completion.xPosition, y: 0.8 }
                ],
                borderColor: completion.color,
                borderWidth: 4,  // Increased from 3
                pointRadius: 0,
                showLine: true,
                tension: 0
            });
        });

        // Add ALL requests as grey (will be drawn first, behind completions)
        if (allRequests.length > 0) {
            datasets.push({
                label: 'Requests',
                data: [],
                borderColor: 'rgba(128, 128, 128, 0.4)',  // Reduced opacity from 0.8 to 0.4
                borderWidth: 2,
                pointRadius: 0
            });

            allRequests.forEach(xPos => {
                datasets.push({
                    label: '',
                    data: [{ x: xPos, y: 0.2 }, { x: xPos, y: 0.8 }],
                    borderColor: 'rgba(128, 128, 128, 0.4)',  // Reduced opacity from 0.8 to 0.4
                    borderWidth: 2,
                    pointRadius: 0,
                    showLine: true,
                    tension: 0
                });
            });
        }

        // Add completion lines last so they draw on top
        datasets.push(...completionLines);

        return datasets;
    }

    function getChartLayoutPadding() {
        // Shared padding to ensure x-axes align perfectly with chart above
        return {
            left: 0,    // Let Chart.js calculate based on y-axis
            right: 15,  // Match on both charts
            top: 5,
            bottom: 5
        };
    }

    function syncChartAlignment() {
        // After initial render, sync the activity chart padding to match main timeline chart
        if (timelineChart && timelineActivityChart) {
            requestAnimationFrame(() => {
                const mainArea = timelineChart.chartArea;
                const activityPadding = {
                    left: mainArea.left,
                    right: timelineChart.width - mainArea.right,
                    top: 5,
                    bottom: 5
                };
                
                timelineActivityChart.options.layout.padding = activityPadding;
                timelineActivityChart.update('none');
            });
        }
    }

    function updateChart(timeline, stepStatus, requestHistory, timelineStart) {
        document.getElementById('timelineInfo').style.display = 'none';
        document.getElementById('timelineChart').style = '';
        document.getElementById('timelineActivityChart').style.display = 'block';

        const maxTime = calculateMaxTime(timeline, timelineStart);
        const dataStreams = timeline?.data_streams || [];
        const datasets = dataStreams.length > 0 ? convertDataStreamsToChartJs(dataStreams) : [];
        const annotations = createChartAnnotations(timeline, timelineStart);

        const sharedXAxisConfig = {
            type: 'linear',
            min: 0,
            max: maxTime,
            ticks: {
                callback: value => formatTimeLabel(Math.floor(value)),
                autoSkip: true,
                maxTicksLimit: 15
            }
        };

        // Main timeline chart
        if (!timelineChart) {
            timelineChart = new Chart(document.getElementById('timelineChart'), {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2.5,
                    layout: {
                        padding: getChartLayoutPadding()
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        annotation: {
                            common: { drawTime: 'beforeDraw' },
                            annotations
                        },
                        legend: { display: datasets.length > 0 }
                    },
                    scales: {
                        x: {
                            ...sharedXAxisConfig,
                            title: { display: true, text: 'Time' },
                            grid: {
                                drawBorder: true,
                                display: true
                            }
                        },
                        y: {
                            title: { display: true, text: 'Watts' },
                            grid: {
                                color: context => context.tick.value === 0 ? '#000000' : undefined
                            }
                        }
                    }
                }
            });
        } else {
            timelineChart.data.datasets = datasets;
            timelineChart.options.plugins.annotation.annotations = annotations;
            timelineChart.options.plugins.legend.display = datasets.length > 0;
            timelineChart.options.scales.x.max = maxTime;
            timelineChart.update('none');
        }

        // Activity chart
        const { stepCompletions, allRequests } = extractActivityData(stepStatus, requestHistory, timelineStart);
        const activityDatasets = createActivityDatasets(stepCompletions, allRequests);

        if (!timelineActivityChart) {
            timelineActivityChart = new Chart(document.getElementById('timelineActivityChart'), {
                type: 'line',
                data: { datasets: activityDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 8,
                    layout: {
                        padding: getChartLayoutPadding()
                    },
                    interaction: { mode: null },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                filter: item => item.text !== ''
                            },
                            onClick: function(e, legendItem, legend) {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);
                                
                                // Toggle visibility
                                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                                
                                // Also hide/show all related datasets with empty labels that have the same color
                                const clickedColor = chart.data.datasets[index].borderColor;
                                chart.data.datasets.forEach((dataset, i) => {
                                    if (i !== index && 
                                        dataset.label === '' && 
                                        dataset.borderColor === clickedColor) {
                                        const datasetMeta = chart.getDatasetMeta(i);
                                        datasetMeta.hidden = meta.hidden;
                                    }
                                });
                                
                                chart.update();
                            }
                        },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: {
                            ...sharedXAxisConfig,
                            display: false,
                            grid: { drawBorder: false, display: false }
                        },
                        y: {
                            display: false,
                            min: 0,
                            max: 1,
                            grid: { drawBorder: false, display: false }
                        }
                    }
                }
            });
            
            // Sync alignment after both charts are created
            syncChartAlignment();
        } else {
            timelineActivityChart.data.datasets = activityDatasets;
            timelineActivityChart.options.scales.x.max = maxTime;
            timelineActivityChart.update('none');
        }
        
        // Re-sync alignment on updates (in case window was resized)
        if (timelineChart && timelineActivityChart) {
            syncChartAlignment();
        }
    }

    // STATUS UPDATES
    
    function handleNewStatus(status) {
        // Store status globally for cycleXsdError
        window.currentStatus = status;

        if (status === null || status === undefined) {
            showCommsError("Failed to retrieve current status.");
            return;
        }
        
        showCommsError(null);

        // update test initialisation text
        // the element 'update-initialised-card' will only exist in the dom if the test is in the init-phase.
        const instructions = status.instructions ?? []
        const initialisedCard = document.getElementById('update-initialised-card')
        if (initialisedCard !== null) {
            // Allow to work with older version of cactus runner that doesn't send the instruction in the runner status
            initialisedCard.innerHTML = initialisedCardBody(instructions);
        }

        // update precondition checks table
        const preconditionChecksTable = document.getElementById('update-precondition-checks-table');
        const preconditionChecks = status.precondition_checks ?? null;
        if (preconditionChecks) {
            preconditionChecksTable.innerHTML = preconditionChecksTableBody(preconditionChecks);
        } else {
            // If there aren't any precondition checks we remove the card entirely.
            const preconditionCard = document.getElementById('precondition-checks-card');
            if (preconditionCard) preconditionCard.remove();
        }

        // update cactus log entries
        document.getElementById('update-log-envoy').innerHTML = status.log_envoy ?? "No logs recorded";

        // update requests table
        const requestTable = document.getElementById('update-requests-table');
        requestTable.innerHTML = requestsTableBody(status.request_history ?? []).join("");

        // update steps table
        const stepsTable = document.getElementById('update-steps-table');
        stepsTable.innerHTML = stepStatusTableBody(status.step_status ?? {}).join("");

        // update criteria table
        const criteriaTable = document.getElementById('update-criteria-table');
        criteriaTable.innerHTML = criteriaTableBody(status.criteria ?? []).join("");

        // update generate table
        const generalTable = document.getElementById('update-general-table');
        generalTable.innerHTML = generalTableBody(status).join("");

        // update metadata table
        const metadataTable = document.getElementById('update-metadata-table');
        metadataTable.innerHTML = metadataTableBody(status.end_device_metadata).join("");

        // update xsd validation errors
        const xsdTable = document.getElementById('update-xsd-table');
        xsdTable.innerHTML = xsdTableBody(status.request_history ?? []).join("");

        // update step instructions
        if ("{{run_status}}" === "started") {
            stepInstructionsEl = document.getElementById('step-instructions')
            if (instructions.length > 0) {
                stepInstructionsEl.innerHTML = alertBanner(getStepInstructions(instructions));
            } else {
                stepInstructionsEl.innerHTML = ""
            }
        }

        // update timeline charts
        updateChart(
            status.timeline, 
            status.step_status, 
            status.request_history,
            status.timestamp_start
        );
    }

    function handleStatusError(status, content) {
        if (status === null) {
            console.error("AJAX error occurred.");
            window.location = runStatusUri;
        } else if (status === 410) {
            console.error("Received HTTP GONE - reloading page as test is finished:");
            window.location = runStatusUri;
        } else {
            console.error("Request failed with status and content:", status, content);
        }
    }

    function parseStatus(rawJsonString) {
        if (!rawJsonString) return null;
        
        try {
            return JSON.parse(rawJsonString);
        } catch (error) {
            console.error('Error parsing status:', error);
            return null;
        }
    }

    function startPollingRunStatus(runStatusUri, pollRateMs) {
        function fetchStatus() {
            xhrRequest(runStatusUri, (content) => {
                setTimeout(fetchStatus, pollRateMs);

                const status = parseStatus(content);
                if (status === null) {
                    console.error("Received invalid status from poll with content:", content)
                }

                try {
                    handleNewStatus(status);
                } catch (error) {
                    console.error("Error during handleNewStatus", error);
                    showCommsError("Error parsing status object from test harness.");
                }


            }, (status, content) => {
                setTimeout(fetchStatus, pollRateMs);
                handleStatusError(status, content);
            });
        }

        setTimeout(fetchStatus, pollRateMs); // start the loop after initial poll delay
    }

    function showRequestDetails(requestId) {
        xhrRequest(`/run/${runId}/requests/${requestId}`, (content) => {
            const data = JSON.parse(content);
            const escape = (s) => s ? s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])) : '';
            
            // Extract first line of request (e.g., "GET /edev HTTP/1.1")
            const requestFirstLine = data.request ? data.request.split('\n')[0].trim() : 'Request';
            
            // Prevent body scroll
            document.body.classList.add('modal-open');
            
            const modal = document.createElement('div');
            modal.id = 'requestModal';
            modal.innerHTML = `
                <div class="modal-backdrop" onclick="closeRequestModal()">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h5>${requestFirstLine}</h5>
                            <button onclick="closeRequestModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <h6>Request</h6>
                            <pre><code>${escape(data.request || 'No request data')}</code></pre>
                            <h6>Response</h6>
                            <pre><code>${escape(data.response || 'No response data')}</code></pre>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }, () => alert('Failed to load request details'));
    }

    function closeRequestModal() {
        const modal = document.getElementById('requestModal');
        if (modal) {
            modal.remove();
            document.body.classList.remove('modal-open');
        }
    }

    addEventListener("load", (event) => {
        // Load initial status at startup
        const initialStatusJson = atob("{{ initial_status_b64 }}");
        const status = parseStatus(initialStatusJson);
        try {
            handleNewStatus(status);
        } catch (error) {
            console.error("Error during handleNewStatus", error);
            showCommsError("Error parsing status object from test harness.");
        }


        // Start polling
        if (runIsLive) {
            const uri = isAdminView ? "{{ url_for('admin_run_status_json', run_id=run_id) }}" : "{{ url_for('run_status_json', run_id=run_id) }}";
            const pollRateMs = 10000; // 10 seconds
            startPollingRunStatus(uri, pollRateMs);
        }
    });



</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.5.0/chart.umd.js"
    integrity="sha512-D4pL3vNgjkHR/qq+nZywuS6Hg1gwR+UzrdBW6Yg8l26revKyQHMgPq9CLJ2+HHalepS+NuGw1ayCCsGXu9JCXA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.0/dist/chartjs-plugin-annotation.min.js"
    integrity="sha256-/wN4amD2yTzKz+D7tsLjxnHXkwhWo2ifLzkxE9jWVew=" crossorigin="anonymous"></script>

{% endblock %}